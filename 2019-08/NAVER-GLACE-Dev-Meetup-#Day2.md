# NAVER GLACE Dev Meetup #Day2

> [행사 안내 URL](https://festa.io/events/424)  
> 장소 : 강남역 2번 출구 메리츠 빌딩 16층 NAVER D2 Startup Factory  
> 시간 : 2019년 8월 21일 19:00 ~ 22:00  
> 참여 목적 :  
> 대규모 시스템에 리액트 & 리액트 네이티브를 잘 적용하고 있는 사례와  
> Spring Boot 코틀린 적용 사례를 참고하기 위함.

## section 1. Glace 팀에 대하여

* Global Place의 합성어

* 조직 문화
  * 신기술 활용, FE 고도화, 개발 효율을 추구.
  * Code == Document 별도 문서는 최소화한다.
    * 코드를 읽기 쉽게 작성.
    * 2중 루프 피하기, 식별 가능한 이름을 사용하는 등의 규칙
  * code review 생활화, micro 소통을 중요시함.

* 사내 생활
  * 정해진 출퇴근 시간 없음, 최소 근무시간 주 15시간 (퇴직금을 지급하기 위한 법적 최소 시간)
  * 수평문화, 직급 없음. 호칭은 모두 OOO님.
  * 누구나 issue를 제시하고, 스스로 issue를 taking한다.

* 현재 서비스 중인 프로젝트
  * LINE conomi - 일본 현지 맛집 찾기 서비스
    * 차후 현재 한국에서 서비스중인 네이버 예약 시스템을 덧붙일 예정.
    * [타베로그](https://tabelog.com)와 경쟁하는 서비스

* 감상
  * 개개인이 알아서 잘하자
  * 정해진 출퇴근 시간이 없다 == 내 할 일 끝나야 집에 간다
  * Code = Document라는 문구가 감명 깊었음
  * 이번 행사의 취지를 약간 잘못 파악하고 참석했다는 생각이 들었음
  * 개발 인력 모집 홍보 취지의 행사로 파악됨
  * 타베로그 이야기에 매우 흥미가 생김

## section 2. Place 개발 - 게으른 개발자가 부지런히 일하는 방법

* 네이버 메일, My Place 서비스 FE 리액트 전환기.
  
* 게으른 개발자?
  * 빌 게이츠의 게으른 사람에게 일을 시킨다는 이론
  * 게으른 게발자 -> 귀찮고 반복적인 업무 자동화 모색 -> 개발 생산성 상승
  * 워라벨은 중요하다! 자동화 연구 -> 워라벨 좋아짐

* 개발자의 생산성을 높이는 문화
  * 보고용 문서 작성은 하지 않는다.
    * 기술 지식/ 사례 공유 문서는 적극 작성!
  * 주간 보고도 Github issue로 정리한다.
  * 동기식 커뮤니케이션은 지양하고 비동기식(깃헙 이슈, 코멘트)을 지향한다.
  
* 리뷰 문화
  * 코드의 문제는 혼자의 책임이 아니다 - 책임 분산
  * 누가 짜도 비슷한 코드 - 이해하기 쉬운 코드
  * Test code 작성보다 Code review가 DevOps에 있어 더 좋은 방법이라고 생각함.
  * 누군가가 휴가를 가도 백업이 쉽다.

* 개발 생산성 & 리팩토링
  * 적은 인원으로 여러 업종에 대한 서비스 프론트 개발
  * 업종 별로 비슷한 여러 페이지 공통화 / 재사용
  * 요구사항에 급히 새로운 업종 추가 - 미용실 개발에 2주 걸림 (재사용에 의한 이득)
  * 업종이 너무 많아져서 리팩토링을 하게 됨
  * 리팩토링은 더 빨리 달리기 위한 준비에 시간을 쓰는 것
  * 기존에 비해 성능, 개선점 등을 중점적으로 고려
  * 각자 관심 있는 주제를 맡아서 자료 조사 / 정리 후 팀원들에게 공유
  * 결과: 리액트 Class Component에서 Functional Component로 모든 코드 전환.
  * GraphQL, Apollo 도입하여 구축
  * 새로운 기술이나 개선 된 코드를 만들고 싶으면 바로 Branch를 따서  
    PR 작성 후 팀원들의 코드 리뷰 후 Merge하는 문화를 만듬.

* 이런 개발자와 일하면 재미있습니다.
  * 끊임 없이 공부하는 개발자.
  * 겪어보지 못한 에러를 보고 희열을 느끼는 개발자 (~~변태~~)

* 감상
  * 부럽다. 우리 회사에도 도입하고 싶다.
  * 혼자서라도 조금씩 할 수 있는 건 해봐야겠다. 그래서 이 문서 작성 시작.
  * 좋은 건 나누자. 나누면 커진다. 좀스럽게 굴지 말고.

## section 3. DevOps in Place

* DevOps에 사용하는 Tool들

  * Git, Jenkins, Lambda(AWS Service), WORKS(NAVER가 만든 업무용 메신저)활용.
    * ~~WORKS에 대한 발표자 피셜 : Slack보단 구리지만 많이 쓸만해졌다.~~

* Git Branch 운영.
  
  * Master*
    * 정기 배포, 핫픽스 모두 릴리즈를 통해 태그 생성 후 배포
    * 핫픽스 브랜치의 base
    * PR 없이는 merge 불가, 필요 review 수는 탄력적으로 조정

  * Develop*
    * 개발 완료된 코드를 merge
    * 배포 시엔 master에 merge후 배포
    * 정기 배포 브랜치의 base

  * Test
    * Test 환경에 Continuous Delivery
    * 자유롭게 merge하고 overwrite 가능

* Jenkins

  * Master
    * 업데이트 되면 Docker image build, test, push
    * 미리 image 보안 검수 요청 - 3분 정도 걸리는 자동화 보안 검수에 들어감.
    * Production 환경에 배포할 image 준비

  * Test
    * 업데이트 되면 image build, test, push
    * Test 환경에 image 배포
    * CD pipeline 결과 DB에 적재
  
  * etc.
    * PR 생성시 반드시 eslint / tslint prettier로 코드 컨벤션 강제
    * 배포 결과 메신저로 받음.
    * 게으른 개발자가 자동화할 수 있는 기능들을 람다를 사용해서 구축
  
  * 감상
    * 어느 정도 우리 팀에도 구축 되어있는 부분
    * 조직의 규모와 수준을 생각해서 우리만의 깃 운영의 노하우를 쌓을 필요가 있음
    * 커밋할 때 코드 컨벤션 강제하는 것은 좋은 운영 노하우라 여겨짐.

## section 4. React Native를 활용한 Cross Platform 앱 개발 성공기

* 개발한 서비스 : 일본 맛집 리뷰 어플 - LINE conomi
  * 잠시지만 애플 앱스토어 1위 등극.
  * 바이럴 조작이 불가능하도록 진짜로 먹고  
    영수증을 OCR로 찍어서 올린 뒤 평가, 추천하면 라인 포인트로 보상을 해줌.

* 서비스 시작은 Web Service로 시작
  * 일본 현지 반응 - 리뷰에 웹은 불편하다.
  * Web -> App으로 전환

* 팀원들은 전원 Web 개발자였음.
  * 하이브리드 앱 기술을 사용하자!
  * 기술 조사
    * React Native
    * Flutter
    * Xamarin
    * Cordova
    * ionic
    * Weex
    * NativeScript
    * etc…
  * 이미 팀 내에서 React를 많이 사용하고, 여러가지 장점을 고려하여 React Native로 결정
    * Markup 담당자와 분업 가능
    * Redux / MobX / Apollo / GraphQL / Lottie / React-Spring 등  
      기존 React에 사용하는 기술들 전부 그대로 활용 가능.

* 앱만의 경험들
  * UX Launch Screen을 앱에서 띄워줘야함.
  * 개발 자체보다 오히려 Apple App Store / Android Play Store에 출시하는 것이 가장 어려웠음.
  * 처음 겪는 생태계에 관한 삽질이 많았음.

* 성능 이슈 - 브릿지
  * JS는 싱글 쓰레드 + 비동기
  * base64 encoding 이슈
  * ScrollView vs FlatList
    * ScrollView는 구현은 쉬우나 무한 휠 스크롤 시 메모리를 많이 차지함.
    * FlatList는 화면에서 보이지 않는 부분은 지우므로 메모리를 절약.
  * React Native에 최적화된 Node engin을 직접 만들어서 오픈소스에 기여함.
  * 결론 : React Native의 넓은 커뮤니티를 통한 해결 방법은 다 있다.

* 장점
  * 웹처럼 강제 배포가 가능하다.
  * 구버전 Deprecate 가능하다.

* 개발 문화
  * 풀 스택을 지향 - 니 것 내 것 없다.
  * 코드 리뷰 중심
    * 기술 -> 공유 -> 성장
    * 코드 퀄리티 상승
  * 개발자는 최초의 제품 사용자다.
  * 일본 출장가서 직접 먹고 찍고 테스트해봄.

* 감상 
  * 개인적으로 제일 관심이 많이 가는 서비스
  * 경쟁 서비스라고 할 수 있는 타베로그와 차별점이 있음.
    * 이하는 일본 여행 3번 및 워홀 1년간 살면서 사용한 타베로그에 대한 지식을 포함한 개인적 분석
    * 食べログ
      * 자체 매거진도 운영하고 별점 중심의 서비스
        * 별점에 따른 점포 랭킹이 있고  
          프리미엄 서비스를 가입해야만 랭킹 순 검색이 가능.
      * 일본판 온라인 미슐랭 가이드의 느낌이 강함.
        * 물론 평점은 평가단이 따로 있는 것은 아님. 유저들이 만들어 가는 것.
      * 미각에 강력하게 구애받는 일본인들의 특성이 강한 서비스
        * 다른 국가에 로컬라이징하여 서비스하기 힘든 모델, 오타쿠 감성이 강함
        * 일본에 여행오는 외국인들 대상 글로벌 서비스 중.
    * LINE Conomi
      >  현지 라인 계정없이 로그인 하지 않고 사용하여 실제 서비스 로그인 후 사용시 차이가 있을 수 있음.
      * 사진, 리뷰어 중심의 서비스
        * 메인에 리뷰어들이 올린 사진이 중심
        * 가게 랭킹은 찾지 못했고 리뷰어 랭킹이 있음.
      * 비교적 가벼운 느낌, 인스타 감성(インスタ映え)
      * 그러나 영수증 OCR을 반드시 업로드 해야하는 정책으로 신뢰도를 올릴 수 있게 함.
      * 젊은 세대들에게 타베로그보다 접근성, 화제성이 좋을 것으로 보임.
      * 가치 평가가 다를 수 있음. (맛보다 비쥬얼 위주가 된다던지)
    * 매우 관심이 가는 서비스이므로 일본 친구들에게 반응도 살펴볼 가치 있음.

## section 5. 네이버가 만든 테스트 툴 nGrinder

* 간단 정리
  * grinder라는 오픈소스를 네이버가 튜닝한 것.
  * URL만으로도 테스트가 가능.
  * 각종 부하 테스트가 가능하다. 회사에서 사용해볼 가치 있음.

## section 6. 네이버 여행 오픈하다 오픈소스 만든 이야기 (feat. GraphQL)

* GraphQL 맛보기
  * Query에 원하는 정보를 조회하는데 필요한 k:v를 넘겨주면  
    그에 맞는 정보들을 객체로 리턴하는 방식
  * RESTful 방식과 달리 End Point가 1곳이다.
  * 추가 요구사항이 생길 경우 여러 정보를 조합하기가 쉽다.
  * 단점은 클라이언트쪽에서 구조적으로 해결해야함.

* 단점을 해결하기 위해 직접 오픈소스 라이브러리를 만들었다.

* 감상
  * 생소하고 어려울 수 있는 내용이나 시간이 짧아 설명이 충분치 못했음.
  * 그러나 기술에 대한 호기심이 생기는 데는 충분한 세션이었음.
  * 앞으로 리액트를 공부하게 될 경우 같이 사용해보는 것도 좋을 듯.

## section 7. Spring Boot 기반의 네이버 예약 서버에 Kotlin 적용하기

* Kotlin 특징
  * IntelliJ IDEA로 유명한 JetBrains가 만든 언어. Android 공식 언어로 채택됨.
    * Android Studio가 IDEA 기반으로 제작됨
  * Kotlin은 JVM에 완벽 호환 되는 언어로 JAVA와 혼용할 수 있음.
  * Getter/Setter를 자동 생성하는 문법이 있어 Lombok을 대체할 수 있음.
  * 모던 언어로 코드 길이가 굉장히 짧아진다.
  * 주요 문법은 공식 문서 참고.

* 레거시 Java Spring Boot에 적용 시 주의점.
  * Lombok이 적용된 클래스를 Delombok 해준 후 코틀린으로 전환
    * IntellJ에 자동 Delombok 기능이 있으나 사용할 경우 코드가 지저분한 단점이 있음.
  * 기본 boolean 타입 Gette/Setter의 경우 메서드 명이 Lombok과 달라서  
    기존 코드에 적용 시 직접 메서드명을 지정해 줄 필요가 있다.
  * equals 메서드의 경우 기존 코드에 적용 시 이슈가 있어  
    equals를 오버라이딩하는 부모 클래스를 만든 뒤 상속 받는 방식으로 처리
  * QuaryDSL QClass를 생성할 경우 컴파일의 우선순위 이슈로  
    코틀린으로 작성된 entity의 Getter/Setter를 찾지 못하는 문제가 발생.

## 채용에 관하여

* 본래의 목적은 아니어서 질문 준비를 많이 하진 못함.

* 인재를 선발하는 방법
  * 주니어 개발자에겐 기술 스택보단 알고리즘, 자료구조와 같은 기본 컴퓨터 공학을 중시함.
  * 프레임워크는 알면 좋지만 입사 팀이 사용하는 스택에 맞춰서 배우면 되는 것

## 행사가 끝난 후 꼭 필요하다고 생각되는 정보들 (계속 추가 예정)

* 자주 언급되었던 PR이란?
  * [Pull Request 이해하기](https://velog.io/@zansol/Pull-Request-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)
  * [git 초보를 위한 풀리퀘스트(pull request) 방법](https://wayhome25.github.io/git/2017/07/08/git-first-pull-request-story/)

* React Native
  * [React Native 도입 시 고려 사항들](https://velog.io/@honeysuckle/React-Native%EB%A1%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EB%A5%BC-%EC%A7%84%ED%96%89%ED%95%98%EA%B8%B0%EC%A0%84-%EA%B3%A0%EB%A0%A4%EC%82%AC%ED%95%AD-%EB%8B%A8%EC%A0%90-%EC%95%84%EB%8B%98)

  * [NAVER Tech Talk: React Native (2018년 7월, 10월)](https://d2.naver.com/news/5689003)
